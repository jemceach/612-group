---
title: "report"
author: "Juliann McEachern, Rajwant Mishra,Christina Valore"
date:  " July 16, 2019"
output: 
  html_document:
    theme: flatly
    highlight: pygments
    toc_depth: 2
    df_print: paged
    code_folding: hide
---
# Overview {.tabset .tabset-fade .tabset-pills}

Our project used data from Kaggle's 2013 Yelp Challenge. This challenge included a subset of Yelp data from the metropolitan area of Phoenix, Arizona. Our data takes into account user reviews,ratings, and check-in data for a wide-range of businesses. The four datasets consist of the following observations and variables:

## Business
*  'type': 'business',
*  'business_id': (encrypted business id),
*  'name': (business name),
*  'neighborhoods': [(hood names)],
*  'full_address': (localized address),
*  'city': (city),
*  'state': (state),
*  'latitude': latitude,
*  'longitude': longitude,
*  'stars': (star rating, rounded to half-stars),
*  'review_count': review count,
*  'categories': [(localized category names)]
*  'open': True / False (corresponds to permanently closed, not business hours),

## Review
*  'type': 'review',
*  'business_id': (encrypted business id),
*  'user_id': (encrypted user id),
*  'stars': (star rating),
*  'text': (review text),
*  'date': (date, formatted like '2012-03-14', %Y-%m-%d in strptime notation),
*  'votes': {'useful': (count), 'funny': (count), 'cool': (count)}

## User
Some user profiles are omitted from the data because they have elected not to have public profiles. Their reviews may still be in the data set if they are still visible on Yelp.

*  'type': 'user',
*  'user_id': (encrypted user id),
*  'name': (first name),
*  'review_count': (review count),
*  'average_stars': (floating point average, like 4.31),
*  'votes': {'useful': (count), 'funny': (count), 'cool': (count)}

## Checkin
If there are no checkins for a business, the entire record will be omitted.
*  'type': 'checkin',
*  'business_id': (encrypted business id),
*  'checkin_info' (example of checkin format)
  *  '0-0': (number of checkins from 00:00 to 01:00 on all Sundays),
  *  '1-0': (number of checkins from 01:00 to 02:00 on all Sundays), 
  *  '14-4': (number of checkins from 14:00 to 15:00 on all Thursdays),
  *  '23-6': (number of checkins from 23:00 to 00:00 on all Saturdays)

If there was no checkin for an hour-day block it will not be in the dictionary,

# Getting Started

The following packages were used in `R` to complete our project. 

```{r}
## data processing packages
library(dplyr); library(tidyr);library(jsonlite);library(stringr)

##formatting packages
library(knitr); library(kableExtra); library(default)

##visualization packages
library(ggplot2)

##recommender packages
library(recommenderlab); library(Metrics); library(lsa); library(diveRsity)
```

## Data Aquisition

All the data is multiarray of Json, which means file is a collection of json data. We will use  `stream_in` function, which parses json data line-by-line from our files stored within the data folder of our repository. 

```{r, message=F, warning=F}
# Business Data 
business<-stream_in(file("data/yelp_training_set_business.json"),verbose = F)
# user Data 
user <-stream_in(file("data/yelp_training_set_user.json"),verbose = F)
# checkin Data 
checkin <-stream_in(file("data/yelp_training_set_checkin.json"),verbose = F)
# review  Data 
review <-stream_in(file("data/yelp_training_set_review.json"),verbose = F)
```


## Data Transformations {.tabset .tabset-fade .tabset-pills}

### Business

There were 1224 business in our data that were permanently closed. These companies accounted for 9.8% of all businesses, which we filtered out and removed from our data. There were 508 unique category tags listed within our business data. We choose to limit the scope to our recommender system to only businesses with tags related to food and beverages.

**Change filter to grep. Coersion warning. This will work for now**

```{r, warning=F, comment=F}
# dropped open, neighborhoods(no data), full address, and review count
df_business<-business %>% filter(open == "TRUE") %>% select(-open, -neighborhoods, -full_address, -review_count, -business) %>% mutate(categories, sapply(categories, toString))

# create category filter
filter <- 'Argentine| Burmese| Cambodian| Cocktail Bars|Laotian|Lebanese|Live/Raw Food|Russian|African|Champagne Bars|Kosher|Modern European|Scandinavian|Taiwanese|Tapas/Small Plates|Afghan|Brazilian|Food Trucks|Shaved Ice|Wineries|Dim Sum|Ethiopian|Fondue|Hookah Bars|Persian/Iranian|Peruvian| Polish| Seafood Markets| Tapas Bars|Halal|British| Cheese Shops|German|Spanish|Cheesesteaks|Cuban|Do-It-Yourself Food|Gastropubs|Salad|Creperies|Soup|Chocolatiers & Shops|Filipino|Food Stands|Fruits & Veggies|Meat Shops|Mongolian|Soul Food|Comfort Food| Irish|Fish & Chips|Cajun/Creole|Caribbean|Pakistani|Southern|Candy Stores|Vegan|Latin American|Breweries|French|Gay Bars|Korean|Gluten-Free|Hawaiian|Farmers Market|Vegetarian|Middle Eastern|Ethnic Food|Indian|Pubs|Chicken Wings|Dive Bars| Juice Bars & Smoothies|Vietnamese|Cafes|Wine Bars|Bagels|Diners|Hot Dogs|Tex-Mex|Donuts|Greek|Thai| Desserts|Mediterranean|Beer| Wine & Spirits|Seafood|Sushi Bars| Lounges|Steakhouses|Buffets|Japanese|Sports Bars|Delis|Bakeries|Specialty Food|Breakfast & Brunch|Ice Cream & Frozen Yogurt|Burgers|Italian| Chinese|Coffee & Tea|American (New)|Sandwiches|Fast Food|Pizza|American (Traditional)|Bars|Mexican|Food| Restaurants'

# filter businesses using filter
df_business <- df_business %>% filter(str_detect(categories, filter))
```
```{r}
df_business %>% head() %>% kable(caption="Preview Business Data") %>% kable_styling()
```


### User

Insert changes here. 


We changed the business and user columns name for clarity to better identify our variables. We have also dropped some fields and rearranged few of them. Only keeping following fields for by dataset:

|      **BUSINESS**       | **USERs**              | **REVIEWS* *     | **CHECKIN**   |
|:-------------------:|--------------------|--------------|-----------|
| bus_city            | user_id            | user_id      | NO CHANGE |
| business_id         | usr_name           | review_id    |           |
| bus_categories      | usr_review_count   | rev_stars    |           |
| bus_name            | usr_type           | rev_date     |           |
| bus_open            | usr_average_stars  | rev_text     |           |
| bus_review_count    | usr_funny          | rev_type     |           |
| bus_state           | usr_useful         | business_id  |           |
| bus_type            | usr_cool           | rev_funny    |           |
| bus_stars           | rev_useful         |              |           |
| bus_categories_all  | rev_cool           |              |           |

Only "full_address" ,"longitude" and "latitude" were dropped from MAIN Data set to reduce the dataset for model, these information can be accessed from main data set when required.


### Given Data

```{r}
# Business Data
# sort data by Business Name alphabetically
df_business<- business[ , order(names(business))] %>% .[,c(3,1,2,7,9,10,12,13,11)] %>% mutate(df_business,categories_all = as.character(categories)) 

## Keeping STARS for Training set at index 11
# Changing the columns name for clarity so that we can identify business data and user data ( except the keys )

 HeaderName_bus <- c( "bus_city",
                  "business_id",
                  "bus_categories",
                  "bus_name",
                  "bus_open" ,
                  "bus_review_count",
                  "bus_state",
                  "bus_type",
                  "bus_stars",
                  "bus_categories_all")
 names(df_business) <- HeaderName_bus

# User Data
# Votes is dataframe in the user dataset , we will read this data and then bind columns with user data.
df_user <- user %>% select( -votes) %>% bind_cols(.,user$votes) %>% .[,c(1,2,4,5,3,6,7,8)]
df_user_long <- gather(df_user,key= "mood", value = "rating",funny,useful,cool)
# Updating the name of the Users Votes column to user_funny , user_usefull, user_cool
HeaderName_usr <- c("user_id","usr_name","usr_review_count", "usr_type","usr_average_stars","usr_funny","usr_useful","usr_cool")

names(df_user) <- HeaderName_usr

#checkins data

#         '0-0': (number of checkins from 00:00 to 01:00 on all Sundays),
#         '1-0': (number of checkins from 01:00 to 02:00 on all Sundays), 
#         ... 
#         '14-4': (number of checkins from 14:00 to 15:00 on all Thursdays),
#         ...
#         '23-6': (number of checkins from 23:00 to 00:00 on all Saturdays)

# checkin_info is a dataframe with the above structure of the data, we would extract this info and append it to the Checkin Table against the Business ID.
df_main_train_checkin <- checkin  %>% select( -checkin_info) %>% bind_cols(.,checkin$checkin_info) # %>% .[,c(1,2,4,5,3,6,7,8)]


#Reviews Data 
df_review_vote <- review$votes
df_review <- review  %>% select( -votes) %>% bind_cols(.,df_review_vote) 
HeaderName_rev <- c("user_id" ,
                "review_id",
                "rev_stars",
                "rev_date" ,
                "rev_text" ,
                "rev_type" ,
                "business_id",
                "rev_funny"   ,
                "rev_useful" ,
                "rev_cool")
names(df_review) <- HeaderName_rev
```

### Transformed Data 
We then joined our dataframes using the `Business_ID` and `User_ID` as unique keys. 

1. We started with creating Business and Review dataset with `Business_ID` as key .
2. We created similar user and Review dataset with `User_ID` as key
3. Finally we merged the above two dataset into one using the `Business_ID` and `User_ID` as unique keys. 
4. During the first two step we have created few duplicated as part of Review data, so in final data set we have dropped the duplicate review columns.

```{r}
#----------------------------------------------------------------------------------------------
# Building Main data set by Joining all the above data sets on key of Business_ID and User_ID
#----------------------------------------------------------------------------------------------

#Group all reviews that have a business with a star rating
review_bus  <- inner_join(df_review,df_business,by=("business_id"))

#Group all reviews that have and User's data
review_user <-   inner_join(df_review,df_user,by=("user_id"))

# joining all the "Review and Users" information with  the "Review and Business"  Dataset. 
# Moving Key in the Begning 
DF_MAIN <- inner_join(review_bus,review_user[,-c(2,3,4,5,6,8,9,10)], 
                              by =c("business_id","user_id")) %>% .[,c(1,2,7,3,4,5,6,8:26)]
# Appending the Checkins information for the Business 
DF_MAIN_CHK <- inner_join(DF_MAIN,df_main_train_checkin[,-c(1)],by=("business_id"))

```

## Data Introduction  {.tabset .tabset-fade .tabset-pills}

### Business
This dataset list business information with average business rating, along with category of the Business.
<center>**Business Train Data** </center>
 `r head(df_business)`
### Review
Review is main dataset here, it holds link to Users and Business and the corresponding Text Reviews are listed along with ratings.
<center>**Review Train Data** </center>
`r head(df_review)`

### User
Users Holds all the information about user, average rating of the Users given so far, count of the review and different count of Votes on "Cool", "Useful" and "funny".

<center>**User Train Data** </center>
`r head(df_user) `

### Checkin 
Checkin information is round the clock and 7 days data of the Customer's checkin. Column name start with hour-Day 
here hours [00 to 23]- [0 to 6]

<center>**Checkin Train Data** </center>
`r head(df_main_train_checkin)`

## Final Data: 
* We renamed All the Columns from Business (bus_),User(usr_) and Review (rev_) dataset, so that we can identify them from the Big dataset
* Review dataset will be combined with User and Business dataset, with User_ID and Business_Id as key
* Final Dataset is then combined with Checkin information of the Businesses 


```{r echo=FALSE}
# DT::datatable(head(DF_MAIN,10), caption = "Review Data")
# head(DF_MAIN_CHK,10) %>% kable(caption="Data with Checkins Info") %>% kable_styling()

head(DF_MAIN_CHK,10) 

```

## Data Exploration {.tabset .tabset-fade .tabset-pills}

### Business Categories 

```{r}
df_business_long<- df_business %>%  
  unnest("bus_categories"= df_business$bus_categories ,.id= "id") %>% .[,c(2,3,4,5,6,9,10,1,8)] # Star column at index at 8

df_business_long

# All Business Catgories 
df_business_long %>% filter (bus_open== TRUE) %>% select (business_id,bus_categories,bus_state) %>% group_by(bus_categories) %>% dplyr::summarise(Count=n()) %>%   ggplot(aes(x = bus_categories, y = (Count))) +
         geom_point()+
          theme(axis.text.x=element_text(angle=90, hjust=1))+
    xlab(label = "Business Categories")

# Business Categories with 350+ Business
df_business_long %>% filter (bus_open== TRUE) %>% select (business_id,bus_categories,bus_state) %>% group_by(bus_categories) %>% unique() %>% dplyr::summarise(Count=n()) %>% arrange(.,desc(Count)) %>% filter (Count >= 350) %>%   ggplot(aes(x = bus_categories, y = (Count))) +
         geom_bar(stat = "identity") +
          theme(axis.text.x=element_text(angle=90, hjust=1))+
    xlab(label = "Categories with 350+ Business")+
  geom_label(aes(label = Count),  color="white" , fill= "black",nudge_y = -0.02)


## Focus Category 
gl_focus_category <- c("Food","Restaurants","Shopping")
```

### Business States/City
```{r}

# All Business By State
df_business %>% filter (bus_open== TRUE) %>% select (business_id, bus_state) %>% group_by(bus_state) %>% dplyr::summarise(Count=n()) %>%   ggplot(aes(x = bus_state, y = log(Count))) +
         geom_bar(stat = "identity") +
          theme(axis.text.x=element_text(angle=20, hjust=1))+
    xlab(label = "Business State")+
  geom_label(aes(label = Count),  color="white" , fill= "black",nudge_y = -0.02)


# All Business City
df_business %>% filter (bus_open== TRUE) %>% select (business_id, bus_city) %>% group_by(bus_city) %>% dplyr::summarise(Count=n()) %>%   ggplot(aes(x = bus_city, y = Count)) +
         geom_bar(stat = "identity") +
          theme(axis.text.x=element_text(angle=90, hjust=1))+
    xlab(label = "Business City")+
  geom_text(aes(label = Count), colour = "blue", fontface = "bold" ,position = position_stack(vjust = 1.1),check_overlap=TRUE)


# All Business City by Focus Category
df_business_long %>% filter (bus_open== TRUE,bus_categories %in% gl_focus_category ) %>% select (business_id, bus_city,bus_categories) %>% unique()%>% group_by(bus_city,bus_categories) %>% dplyr::summarise(Count=n()) %>%   ggplot(aes(x = bus_city, y = Count, fill=bus_categories)) +
         geom_bar(stat = "identity") +
          theme(axis.text.x=element_text(angle=70, hjust=1))+
    xlab(label = "Business in City by Focus Category")
  
```

### Rating
```{r}
# All Business Categories by Rating
df_business_long %>% filter (bus_open== TRUE,bus_categories %in% gl_focus_category ) %>% select (bus_categories,bus_city, bus_stars) %>% unique()%>% group_by(bus_city, bus_stars) %>% dplyr::summarise(Count=n()) %>%   ggplot(aes(x = bus_stars, y = Count,fill= bus_city)) +
         geom_bar(stat = "identity") +
          theme(axis.text.x=element_text(angle=90, hjust=1))+
    xlab(label = "Stars Rating by City")

  # geom_text(aes(label = Count), colour = "blue", fontface = "bold" ,position = position_stack(vjust = 1.1),check_overlap=TRUE)



# All Business Categories by Rating
df_business_long %>% filter (bus_open== TRUE,bus_categories %in% gl_focus_category ) %>% select (bus_categories,bus_city, bus_stars) %>% unique()%>% group_by(bus_city, bus_categories,bus_stars) %>% dplyr::summarise(Count=n()) %>%   ggplot(aes(x = bus_stars, y = Count,fill= bus_categories)) +
         geom_bar(stat = "identity") +
          theme(axis.text.x=element_text(angle=00, hjust=1))+
    xlab(label = "Stars Rating by Focus Category")

# Count of Business by Category 
fct_count(df_business_long$bus_categories,sort = TRUE) %>% rename(.,c("f"= "Name","n"="Count"))
# library(forcats) 
# 
# plot(fct_count(df_business_long$bus_categories,sort = TRUE))
# 
# unique(df_business_long$bus_state)
```
### User {.tabset .tabset-fade .tabset-pills}

```{r}

# Avg Rating Given by User
df_user %>% select (user_id,usr_average_stars,usr_review_count) %>%
  # group_by(user_id,usr_average_stars,usr_funny) %>% 
  # dplyr::summarise(Count=n()) %>%   
  ggplot(aes(x = round(usr_average_stars), y = usr_average_stars)) +
         geom_bar(stat = "identity") +
          theme(axis.text.x=element_text(angle=00, hjust=1))+
    xlab(label = "Avg Rating Given by User")

```

### Review 


```{r}
library(lubridate)
# Avg Rating Given by User
df_review %>% select (rev_stars,rev_date ) %>% 
  mutate(month = month(as_date(rev_date) )) %>% group_by(month) %>% 
  dplyr::summarise(Count=n()) %>%  
  ggplot(aes ( x= factor(month),y = Count)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x=element_text(angle=00, hjust=1))+
  xlab(label = "Avg Rating Given by User")


str_split(df_review$rev_date[1],"-",n=3,simplify = TRUE)[2]


```




## Data Preparation for Model {.tabset .tabset-fade .tabset-pills}

## Matrix Building 
We converted our raw ratings data into a user-item matrix to test and train our subsequent recommender system algorithms.

```{r}

# create user item matrix with 500 items only as I was getting storage error while bulding user item matrix with all the item. We Decided  to use only category "Restaurant" & "Shopping" for our Recommndation .

#---------------------------------TEAM NOTE:
# I Thought we can use TWo category to make problem more close to the actual problem, where we handle more than one Category to recommend.
#---------------------------------TEAM NOTE:

# https://github.com/tidyverse/tidyr/issues/426

#Settting up the Business Category 
str_Category <- "Restaurant|Shopping"

# Creating User Item Matrix 
ui_matrix_star <- DF_MAIN %>% filter(str_detect(bus_categories_all, str_Category)) %>% select(user_id, business_id, rev_stars) %>% 
  group_by_at(vars(-rev_stars)) %>%  #  # group by everything other than the value column.
  dplyr::mutate(row_id=1:n()) %>% ungroup() %>%  # build group index
  spread(key=business_id, value=rev_stars) %>%    # spread
  select(-row_id)  # drop the index

rownames(ui_matrix_star)<-ui_matrix_star$user_id # set row names to user_id
ui_matrix_star<-ui_matrix_star %>% select(-user_id) %>% as.matrix()# remove user_id from columns
umat <- as(ui_matrix_star,"realRatingMatrix") # save real ratings for algo 
real_ui_matrix_star <- as(ui_matrix_star,"realRatingMatrix") # save real ratings for algo 



# preview matrices 
as.data.frame.array(ui_matrix_star) %>% head() %>% kable(caption="Preview of User-Item Matrix (User-Business)") %>% kable_styling() %>% scroll_box()


```


## Training and Test Subsets

Finally, our data was split into training and tests sets for model evaluation of both two recommender algorithms. We split our data with 10 k-folds using the `recommendaerlab` package. 80% of data was retained for training and 20% for testing purposes.

```{r train-test}
# evaluation method with 90% of data for train and 10% for test
set.seed(1000)

evalu <- evaluationScheme(real_ui_matrix_star, method="split", train=0.5, given=0)

# Prep data
ratings_train <- getData(evalu, 'train')# Training Dataset 
ratings_test_known <- getData(evalu, 'known') # Test data from evaluationScheme of type KNOWN
ratings_test_unknown <- getData(evalu, 'unknown') # Unknow datset used for RMSE / model evaluation

```



## Algorithm{.tabset .tabset-fade .tabset-pills}
### User and Item 
```{r}
# I am planning to see how I can use Business's rating and rev_funny,rev_useful,rev_cool
# and see how users are rating against these parameters, I would check cosine similarlty of user 
# rating with these info and recommend some similar  Business to the Users.


head(df_review[,c(7,8,9,10)])
```



## Conclusion {.tabset .tabset-fade .tabset-pills} 

## Accuracy Metrics {.tabset .tabset-fade .tabset-pills}

# References
* [**Tidyr Issue**](https://github.com/tidyverse/tidyr/issues/426)
* [**Data Overview**](https://www.kaggle.com/c/yelp-recsys-2013/overview)



```{r}

```

<hr><hr>
